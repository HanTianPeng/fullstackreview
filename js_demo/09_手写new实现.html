<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <script>
        /*
            手写new实现
        */
        function create() {
            // 创建一个空对象
            var obj = new Object();
            // 获得构造函数，arguments中去除第一个参数
            var constructorFun = [].shift.call(arguments);
            // 链接原型, obj可以访问到构造函数原型中的属性
            obj.__proto__ = constructorFun.prototype;
            // 绑定this实现继承，obj可以访问到构造函数中的属性
            var ret = constructorFun.apply(obj, arguments);
            // 有限返回构造函数返回的对象
            return ret instanceof Object ? ret : obj;
        }

        if (!Function.prototype.softBind) {
            Function.prototype.softBind = function (obj) {
                var fn = this;
                // 不会所有curried参数
                var curried = [].slice.call(arguments, 1);
                var bound = function () {
                    return fn.apply(
                        (!this || this === (window || global)) ? obj : this,
                        curried.concat.apply(curried, arguments)
                    );

                };
                bound.prototype = Object.create(fn.prototype);
                return bound;
            }
        }

        function foo() {
            console.log('name:' + this.name);
        }

        var obj = {
            name: 'obj'
        },
            obj2 = {
                name: 'obj2'
            },
            obj3 = {
                name: 'obj3'
            };

        // 默认绑定
        var fooObj = foo.softBind(obj);
        console.log(fooObj);
        fooObj();  // obj

        // 隐式绑定
        obj2.foo = foo.softBind(obj);
        obj2.foo();  // obj2

        // 显示绑定
        fooObj.call(obj3);  // obj3

        // 隐式丢失
        setTimeout(obj2.foo, 10);  // obj
    </script>
</body>

</html>