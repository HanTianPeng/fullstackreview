### 原型链继承

  - 构造函数、原型和实例的关系: 每个构造函数都有一个原型对象，原型对象都包含一个纸箱构造函数的指针，而实例都包含一个原型对象的指针

  - 缺点: 多个实例对父类的引用类型属性操作，会造成篡改

```js
function Parent(){
    this.parentProperty = true;
    this.sameProperty = 'parentSame';
    this.colors = ['white', 'red'];
}
Parent.prototype.getParentValue = function(){
    return [this.parentProperty, this.sameProperty];
};

function Child(){
    this.childProperty = false;
    this.sameProperty = 'childSame';
}
/*
    核心步骤1
*/
Child.prototype = new Parent();
Child.prototype.getChildValue = function(){
    return [this.childProperty, this.sameProperty];
};

var child1 = new Child();
console.log(child1.getChildValue());  // [false, "childSame"]
console.log(child1.getParentValue());  // [true, "childSame"]

child1.childInstanceProperty = 'childInstanceProperty';
child1.colors.push('blue');

var child2 = new Child();
console.log(child2.colors);  // ["white", "red", "blue"]

console.dir(child1);
```

### 构造函数继承

  - 借用父类的构造函数来增强子类实例，等同于复制父类的实例给子类

  - 缺点: 只能继承父类的实例属性和方法，不能继承原型属性和方法

  - 缺点: 无法实现父类的复用，每个子类都有父类实例函数的副本，影响性能

```js
function Parent(){
    this.color = ['white', 'red'];
}

function Child(){
    /*
        关键步骤1
    */
    Parent.call(this);
}
var instance1 = new Child();
instance1.color.push('blue');
console.log(instance1.color);  // ["white", "red", "blue"]
console.dir(instance1);

var instance2 = new Child();
console.log(instance2.color);  // ["white", "red"]
console.dir(instance2);
```

### 组合继承

  - 原型链继承 + 构造函数继承, 用原型链实现对原型属性和方法的继承，用构造函数实现实例属性的继承

  - 缺点: 在使用子类创建实例对象时，其原型会存在两份相同的属性/方法

  - 缺点: 无法实现父类的复用，每个子类都有父类实例函数的副本，影响性能

```js
function Parent(name){
    this.name = name;
    this.color = ['red', 'blue'];
}
Parent.prototype.sayName = function(){
    console.log('parent----', this.name);
};
function Child(name, age){
    // 关键步骤2: 第二次调用Parent()
    Parent.call(this, name);
    this.age = age;
}
// 关键步骤1: 第一次调用Parent()
Child.prototype = new Parent();
Child.prototype.construtor = Child;
Child.prototype.sayAge = function(){
    console.log('child----', this.age);
};
/*
        缺点: 
            第一次调用Parent(): 给Child.prototype写入两个属性name, color
            第二次调用Parent(): 给instance1写入两个属性name, color
            属性赋值: 给实例对象instance1上的两个属性赋值，就屏蔽了其原型对象Child.prototype的两个同名属性。
            总结: 在使用子类创建实例对象时，其原型会存在两份相同的属性/方法

*/
var instance1 = new Child('conk', 18);
instance1.color.push('white');  
console.log(instance1.color);  // ["red", "blue", "white"]
instance1.sayName();  // parent---- conk
instance1.sayAge();  // child---- 18
console.dir(instance1);

var instance2 = new Child('pht', 20);
console.log(instance2.color);  // ["red", "blue"]
instance2.sayName();  // parent---- pht
instance2.sayAge();  // child---- 20
console.dir(instance2);
```

### 原型式继承

  - 利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型

  - 缺点: 原型链继承多个实例的引用类型属性指向相同，存在篡改可能

  - 缺点: 无法传递参数

```js
/*
    关键步骤1
*/
function CreateObj(obj){
    function Child(){
        
    }
    Child.prototype = obj;
    return new Child();
}

var parentInstance = {
    name: 'conk',
    colors: ['white', 'blue']
};

var childInstance = CreateObj(parentInstance);
childInstance.name = 'pht';
childInstance.colors.push('red');

parentInstance.name = 'penghantian';
parentInstance.colors.push('green');

console.dir(childInstance);

var childInstance2 = CreateObj(parentInstance);
childInstance2.name = 'child2';
childInstance2.colors.push('yellow');
console.dir(childInstance2);
```

### 寄生式继承

  - 在原型式继承的基础上，增强对象，返回构造函数

  - 缺点: 原型链继承多个实例的引用类型属性指向相同，存在篡改可能

  - 缺点: 无法传递参数

```js
/*
    关键步骤1
*/
function CreateObj(obj){
    function Child(){

    }
    Child.prototype = obj;
    return new Child();
}

/*
    寄生式继承
        在原型式继承的基础上，增强对象。

        缺点: 
            原型链继承对个实例的引用类型属性指向相同，存在篡改可能
            无法传递参数
*/
function enhanceChild(obj){
    var childInstance = CreateObj(obj);
    // 增强对象
    childInstance.eat = function(){
        console.log('===eat==');
    };
    return childInstance;
}

var parentInstance = {
    name: 'conk',
    colors: ['white', 'red'],
};

var childInstance = enhanceChild(parentInstance);
childInstance.eat();  // ===eat===
childInstance.name = 'pht';
childInstance.colors.push('green');
console.log(childInstance.colors);  // ["white", "red", "green"]
console.dir(childInstance);

var childInstance2 = enhanceChild(parentInstance);
childInstance2.eat();  // ===eat===
childInstance2.name = 'penghantian';
childInstance.colors.push('yellow');
console.log(childInstance2.colors);  // ["white", "red", "green", "yellow"]
console.dir(childInstance2);
```

### 原型式继承

  - 利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型

  - 缺点: 原型链继承多个实例的引用类型属性指向相同，存在篡改可能

  - 缺点: 无法传递参数

```js
/*
    关键步骤1
*/
function CreateObj(obj){
    function Child(){
        
    }
    Child.prototype = obj;
    return new Child();
}

var parentInstance = {
    name: 'conk',
    colors: ['white', 'blue']
};

var childInstance = CreateObj(parentInstance);
childInstance.name = 'pht';
childInstance.colors.push('red');

parentInstance.name = 'penghantian';
parentInstance.colors.push('green');

console.dir(childInstance);

var childInstance2 = CreateObj(parentInstance);
childInstance2.name = 'child2';
childInstance2.colors.push('yellow');
console.dir(childInstance2);
```

### 原型式继承

  - 利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型

  - 缺点: 原型链继承多个实例的引用类型属性指向相同，存在篡改可能

  - 缺点: 无法传递参数

```js
/*
    关键步骤1
*/
function CreateObj(obj){
    function Child(){
        
    }
    Child.prototype = obj;
    return new Child();
}

var parentInstance = {
    name: 'conk',
    colors: ['white', 'blue']
};

var childInstance = CreateObj(parentInstance);
childInstance.name = 'pht';
childInstance.colors.push('red');

parentInstance.name = 'penghantian';
parentInstance.colors.push('green');

console.dir(childInstance);

var childInstance2 = CreateObj(parentInstance);
childInstance2.name = 'child2';
childInstance2.colors.push('yellow');
console.dir(childInstance2);
```

### 原型式继承

  - 利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型

  - 缺点: 原型链继承多个实例的引用类型属性指向相同，存在篡改可能

  - 缺点: 无法传递参数

```js
/*
    关键步骤1
*/
function CreateObj(obj){
    function Child(){
        
    }
    Child.prototype = obj;
    return new Child();
}

var parentInstance = {
    name: 'conk',
    colors: ['white', 'blue']
};

var childInstance = CreateObj(parentInstance);
childInstance.name = 'pht';
childInstance.colors.push('red');

parentInstance.name = 'penghantian';
parentInstance.colors.push('green');

console.dir(childInstance);

var childInstance2 = CreateObj(parentInstance);
childInstance2.name = 'child2';
childInstance2.colors.push('yellow');
console.dir(childInstance2);
```

