<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <ul>
        <li>1</li>
        <li>2</li>
        <li>3</li>
        <li>4</li>
        <li>5</li>
        <li>6</li>
    </ul>
    <script>
        /*
            ***易错题***
            闭包考点:

            for循环考点:

            es6考点:

            事件代理考点:
        */
        var listLi = document.getElementsByTagName('li');
        for (var i = 0; i < listLi.length; i++) {
            listLi[i].onclick = function () {
                console.log(i);
            }
        }
        // 点击任何li都是返回6


        // 第一种方式，采用es6的let方法
        for (let i = 0; i < listLi.length; i++) {
            listLi[i].onclick = function () {
                console.log(i);
            }
        }

        // 第二种方式, 闭包
        for (var i = 0; i < listLi.length; i++) {
            listLi[i].onclick = (function (i) {
                return function (i) {
                    console.log(i);
                }
            })(i);
        }

        // 第三种方式, innerHTML
        for (var i = 0; i < listLi.length; i++) {
            listLi[i].onclick = function () {
                console.log(this.innerHTML);
            }
        }
    </script>

    <script>
        /*
            ***易错题***
            函数里面无法对该函数名称进行重新赋值
        */
        var yideng = function yideng() {
            yideng = 1;
            console.log(typeof yideng);  // function
        }

        yideng();
        yideng = 1;
        console.log(typeof yideng);  // number

        var otherName = function yideng2(){
            yideng2 = 1;
            console.log(typeof yideng2);  // function
        }
        otherName();
        yideng2 = 1;
        console.log(typeof yideng2);  // number
    </script>

    <script>
        /*
            ***易错题***
            作用域考点:

            ie浏览器与google浏览器是否存在块元素的区别:
        */
        function yideng() {
            console.log(1);
        }

        (function () {
            if (false) {
                function yideng() {
                    console.log(2);
                }
            }
            yideng();
        })();

        /*
            报错：yideng is not a function 
        */
    </script>

    <script>
        /*
            作用域考点: 

        */
        alert(a);  // function a(){alert(10)}
        a();  // 10
        var a = 3;
        function a() {
            alert(10)
        }
        alert(a)  // 3
        a = 6;
        a();  // a is not function
    </script>

    <script>
        /*
            ***易错题***
            1. 形参与实参:

            2. 重复函数申明会被覆盖
        */
        var x = 1;
        var y = 0;
        var z = 0;
        function add(x) {
            return (x = x + 1);
        }
        y = add(x);
        console.log(y);  // 4
        function add(x) {
            return (x = x + 3);
        }
        z = add(x);
        console.log(z);  // 4
    </script>

    <script>
        /*
            this考点: 

        */
        var length = 10;
        function fn() {
            console.log(this.length);
        }

        var yideng = {
            length: 5,
            method: function (fn) {
                console.log('---arguments---', arguments);
                fn();
                arguments[0]();
            }
        };

        yideng.method(fn, 1);
        /*
            ====>失败
            0===> 10
            0===> 2
        */
    </script>

    <script>
        /*
            this考点:
        */
        this.a = 20;
        function go() {
            console.log(this.a);  // new go()=>40  test.init(go)=> 20  p()=>20
            this.a = 30;
        }
        go.prototype.a = 40;
        var test = {
            a: 50,
            init: function (fn) {
                fn();
                console.log(this.a);  // 50
                return fn;
            }
        }
        console.log((new go()).a);  // 30
        test.init(go);
        var p = test.init(go);
        p();
        /*
            40
            30

            20
            50

            30
            50
            30
        */
    </script>

    <script>
        /*
            ***易错题***
            闭包考点:

            严格模式:
              this指向undefined

            先加与后加:
        */
        var num = 10;
        function yideng() {
            "use strict";
            console.log(this.num++);  // 报错
        }

        function yideng2() {
            console.log(++this.num);  // 11
        }

        (function () {
            "user strict";
            yideng2();
        })();
        yideng();
    </script>

    <script>
        /*
            原型链考点:
        */

        function C1(name) {
            if (name) this.name = name;
        }

        function C2(name) {
            this.name = name;
        }

        function C3(name) {
            this.name = name || 'fe';
        }
        C1.prototype.name = 'yideng';
        C2.prototype.name = 'lao';
        C3.prototype.name = 'yuan';
        console.log((new C1().name) + (new C2().name) + (new C3().name));   // yideng undefined fe
    </script>

    <script>
        /*
            内存引用指向考点:
        */
        function test(m) {
            m = { v: 5 }
        }
        var m = { k: 30 };
        test(m);
        alert(m.v);
        /*
            undefined

            1. window中m所指向的内存地址没有发生改变
            2. 函数中m是新的变量，指向一块新的内存地址
        */
    </script>

    <script>
        /*
            正则表达式考点:
        */
        var regex = /yideng/g;
        console.log(regex.test('yideng'));
        console.log(regex.test('yideng'));
        console.log(regex.test('yideng'));
        console.log(regex.test('yideng'));

        // var allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;
        // function cloneBuffer(buffer, isDeep) {
        //     if (isDeep) {
        //         return buffer.slice();
        //     }
        //     var length = buffer.length,
        //         resut = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        //     buffer.copy(resut);
        //     return resut;
        // }
        // var buf = Buffer.from("laoyuan");
        // // var buf2 = buf;
        // var buf2 = cloneBuffer(buf,true);
        // buf2.write("nodejs");
        // console.log("buf", buf.toString("utf-8"));
        // console.log("buf2", buf2.toString("utf-8"));

        // {
        //     obj:Buffer.from("laoyuan")
        // }

        function cloneReg(target, isDeep) {
            var regFlag = /\w*$/;
            // target.constructor == Regexp
            const result = new target.constructor(target.source, regFlag.exec(target));
            if (isDeep) {
                result.lastIndex = target.lastIndex;
            }
            return result;
        }
        var regex = /yideng/g;
        const reg2 = cloneReg(regex);
        console.log(reg2);
    </script>

    <script>
        /*
            勤用Array.prototype.slice这种方式
        */
        var a = 'abcde';
        a.split('').map(function (valule) {
            console.log(valule);
        });

        Array.prototype.slice.apply(a);
        Array.prototype.slice.call(a);
    </script>

    <script>
        /*
            避免is switch考点；

            请用一句话算出0-100之间学生的学生等级，如90-100输出为1等生，80-90为2等生
        */
        function getLevel(num) {
            return parseInt(num / 10) === 10 ? 1 : 10 - parseInt(num / 10)
        }
        console.log(getLevel(100));
        console.log(getLevel(90));
        console.log(getLevel(80));
        console.log(getLevel(0));
        console.log(getLevel(10));
    </script>
</body>

</html>