<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <script>
        /*
            上面的两个代码中，checkScope()执行完成后，闭包f所引用的自由变量scope会被垃圾回收吗？

            代码1：
                checkScope()执行完成后，代码1中自由变量在特定时间之后会被回收

            代码2:
                自由变量不会被回收

            原因:
                首先要说明的是，
                    现在主流浏览器的垃圾回收算法是标记清除，标记清除并非是标记执行栈的进出，
                    而是从根开始遍历，也就是一个找引用关系的过程，但是因为从根开始，相互引用的情况不会被记入。
                    所以当垃圾回收开始时，从Root(全局对象)开始寻找这个对象的引用是否可达，
                    如果引用链断裂，那么这个对象就会回收。

                闭包中的作用域中parentContext.vo是对象，被放在堆中，栈中的变量会随着执行环境进出而销毁，
                堆中需要垃圾回收，闭包内的自由变量会被分配到堆上，所以当外部方法执行外币后，对其的引用并没有丢。

                每次进入函数执行时，会重新创建可执行环境和活动对象，但函数的[[Scope]]是函数定义时已经定义好的(词法作用域规则)，不可更改。

                


            
        */
        var scope = 'global scope';
        function checkScope() {
            var scope = 'local scope';
            function f() {
                return scope;
            }
            return f;
        }

        // var result = checkScope()();
        // console.log('---result---', result);  // 'local scope'

        // var innerFoo = checkScope();
        // var result2 = innerFoo();
        // console.log('---result2---', result2);  // 'local scope'
    </script>
</body>

</html>