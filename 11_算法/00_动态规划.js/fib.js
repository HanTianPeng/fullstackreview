/*
任何用动态规划的问题都能用递归:
    从子问题入手, 解决原问题, 分两种方法: 自顶向下(递归) / 自底向上(动态规划)
    递归: 借助了函数调用自己实现, 是程序解决问题的方式, 它不会记忆解
    动态规划: 利用迭代将结果存在数组中, 从数组0位开始顺序往后计算
    递归的缺点在于包含重复的子问题, 动态规划的效率更高
动态规划局限性:
    动态规划相比于递归, 有时候不太好理解, 或则边界情况比较难确定
    而且必须是一步步紧邻的, 连续地计算
    结合了记忆化的递归, 灵活很多, 它在递归基础上稍作修改即可, 有时候更好理解, 也少了局限性, 不好用动态规划一定能用它
动态规划的条件:
    1. 最优子结构
    2. 子问题重叠
动态规划的解题思想:
    1. 定义状态:
        1. 最后一步是什么
        2. 化成子问题
    2. 状态转移方程:
    3. 确定边界:
*/
// 509.斐波那契数: easy + DP + 时间复杂度(n)
var fib = function(N) {
    // 边界处理
    if(!N) return 0;
    let dp_0 = 0,
        dp_1 = 1;
    for(let i=1; i<=N; i++) {
        let temp = dp_0;
        dp_1 = dp_0 + dp_1;
        dp_0 = temp;
    }
    return dp_1;
};
// 509.斐波那契数: easy + 递归 + 时间复杂度(2^n)
var fib = function(N) {
    if(N <= 0) return 0;
    if(N === 1) return 1;
    return fib(N-1) + fib(N-2);
};