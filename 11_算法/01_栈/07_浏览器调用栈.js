// 在浏览器中获取调用栈信息

// 方法一: 断点调试

// 方法二: console.trace()

function sum() {
    return add();
}

function add() {
    console.trace();
    return 1;
}

sum();

/*
浏览器JS运行机制:
    JavaScript单线程,所谓单线程是指在JavaScript引擎中负责解释和执行JavaScript代码的线程唯一,同一时间只能执行一件任务

    为什么单线程?
        多线程执行JavaScript，造成修改DOM冲突
    
    解决修改DOM冲突？
        单线程: JavaScript选用了单线程方案 
        死锁: 
    
    单线程带来的问题？
        如果任务队列里有一个任务特别耗时间, 导致这个任务后面的任务一直处于等待状态，就会发生页面卡死，严重影响用户体验。
    
    如何解决任务耗时问题？
        同步：都在主线程(这里的主线程是JavaScript引擎线程)上执行，会形成一个调用栈

        异步：除了主线程外，还有一个任务队列(消息队列)，用于管理异步任务的事件回调，在调用栈的任务执行完毕之后，系统会检查任务队列，看是否有可以执行的异步任务
            1. 任务队列存放的是异步任务的事件回调

调用栈: 管理函数调用关系的一种栈结构
    1. JavaScript最早是运行在浏览器中，然而浏览器只是提供了一个上下文
    2. JavaScript引擎会首先创建一个全局执行上下文，执行函数时候，JavaScript就会创建一个该函数对应的执行上下文
    3. 调用栈是JavaScript用来管理函数执行上下文的一种数据结构，它记录了当前函数执行的位置，哪个函数正在被执行。如果我们执行一个函数，就会为函数创建执行上下文并放入栈顶。如果我们从函数返回，就将它的执行上下文从栈顶弹出。

JS内存机制: 栈(基本类型，引用类型地址) 与 堆(引用类型数据)
    JavaScript中的内存空间主要分为三种类型:
        1. 代码空间: 主要用来存放可执行代码
        2. 栈空间: 调用栈的存储空间就是栈空间
        3. 堆空间
    
    JavaScript中的变量类型有8中, 分为两类: 基本类型、引用类型
        基本类型: 保存在栈内存中的简单数据段
            1. undefined
            2. null
            3. boolean
            4. number
            5. string
            6. bigint
            7. symbol
        
        引用类型: 保存在堆内存中
            1. object
        
        栈空间:
            基本类型在内存中占有固定大小的空间, 所以它们的值保存在栈空间, 我们通过按值访问
            一般栈空间不会很大

            回收栈空间:
                JavaScript引擎通过向下移动ESP指针来销毁存放在栈空间中的执行上下文
        
        堆空间:
            引用类型,值大小不固定, 但是指向值得指针大小(内存地址)是固定的，所以把对象放入堆中, 将对象的地址放入栈中, 这样, 在调用栈中切换上下文时, 只需要将指针下移到上一个执行上下文的地址就可以了,同时保证了栈空间不会很大。
            当查询引用类型的变量时, 先从栈中读取内存地址, 然后再通过地址找到堆中的值. 对于这种, 我们把它叫做 按引用访问
            一般堆内存空间很大,能存放很多数据,但是它内存分配与回收都需要花费一定的时间

            回收堆空间:
                1. V8把堆分成新生代和老生代两个区域:
                    新生代: 用来存放生存周期较短的小对象, 一般只支持1-8M的容量
                    老生代: 用来存放生存周期较长的对象或则大对象
                
                2. V8对这两块使用了不同的垃圾回收器:
                    新生代使用副垃圾回收器
                    老生代使用主垃圾回收器
                
                3. 其实无论哪种垃圾回收器,都采用了同样的流程(三步骤):
                    1. 标记: 标记堆空间中的活动对象(正在使用)与非活动对象(可回收)
                    2. 垃圾清理: 回收非活动对象所占用的内存空间
                    3. 内存整理: 当进行频繁的垃圾回收时, 内存中可能存在大量不连续的内存碎片, 当需要分配一个需要占用较大连续内存空间对象时, 可能存在内存不足现象,所以这时候需要整理这些内存碎片
                
                4. 副垃圾回收器与主垃圾回收器虽然采用同样的流程, 但使用的回收策略与算法是不同的

                5. 副垃圾回收器:
                    1. 采用Scavenge算法及对象晋升策略来进行垃圾回收
                        1. 所谓Scavenge算法,即是把新生代空间对半划分为两个区域: 一半是对象区域, 一半是空闲区域
                        2. 新加入的对象都加入对象区域,当对象区域满的时候,就执行一次垃圾回收, 执行流程如下:
                            1. 标记: 首先要对区域内的对象进行标记(活动对象,非活动对象)
                            2. 垃圾清理: 然后进行垃圾清理,将对象区的活动对象复制到空闲区域,并进行有序的排列,当复制完成后, 对象区域与空闲区域进行翻转,空闲区域晋升为对象区域,对象区域晋升为空闲区域
                        3. 翻转后,对象区域是没有碎片的,此时不需要进行第三步(内存整理了)
                        4. 但新生代区域很小,一般1-8M的容量,所以它很容易满,所以, JavaScript引擎采用了对象晋升策略来处理,即只要对象经过两次垃圾回收之后依然继续存活,就会被晋升到老生代区域中
                
                6. 主垃圾回收器:
                    1. 老生代区域里除了存在从新生代晋升来的存活时间久的对象,当遇到大对象时,大对象也会直接分配到老生代
                    2. 所以主垃圾回收器主要保存存活久的或占用空间大的对象,此时采用Scavenge算法就不合适了,V8中主垃圾回收器主要采用标记-清除法进行垃圾回收, 执行流程如下:
                        1. 标记: 遍历调用栈,看老生代区域堆中的对象是否引用, 被引用的对象标记为活动对象, 没有被引用的对象(待清理)标记为垃圾数据
                        2. 垃圾清理: 将所有垃圾数据清理掉
                        3. 内存整理: 标记-整理策略,将活动对象整理一起
                    3. V8浏览器会自动执行垃圾回收,但由于JavaScript也是运行在主线程中的,一旦执行垃圾回收,就要打断JavaScript的运行,可能会或多或少的造成页面的卡顿,影响用户体验,所以V8决定采用增量标记算法回收:
                        1. 即把垃圾回收拆成一个个小任务,穿插在JavaScript中执行
*/