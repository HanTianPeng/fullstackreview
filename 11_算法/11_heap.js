/*
    堆(Heap):
        > 用数组实现的二叉树,所以它没有使用父指针或则子指针;堆根据堆属性来排序,堆属性决定了树中节点的位置

    堆的常用方法:
        > 构建优先队列
        > 支持堆排序
        > 快速找出一个集合中的最小值(或者最大值)

    堆属性:
        > 最大堆:
            父节点的值比每一个子节点的值都要大
        > 最小堆:
            父节点的值比每一个子节点的值都要小
    
    注意点:
        堆的根节点中存放的是最大或则最小元素,但是其他节点的排序顺序是未知的。

    堆与普通树之间区别:
        > 节点顺序:
            二叉搜索树: 左子节点 < 父节点 < 右子节点;
            最大堆: 两个子节点都比父节点小
            最小堆: 两个子节点都比父节点大

        > 内存占用:
            普通树: 占用内存空间比它们存储的数据要多,因为必须为节点对象以及左右子节点指针分配内存
            堆: 仅仅使用一个数据来存储数组,且不使用指针

        > 平衡:
            二叉搜索树必须是平衡的情况下，其大部分操作的复杂度才能达到O(logn)
            堆中不需要整棵树都是有序的，我们只需要满足堆属性即可，所以在堆中平衡不是问题。因为堆中数据的组织方式可以保证O(logn)的性能

        > 搜索:
            二叉搜索树很快
            堆很慢,但是堆的目的是将最大或则最小的节点放在最前面,从而快速的进行相关插入/删除操作

    堆的存储:
        parent(i) = i / 2
        left(i) = 2i + 1
        right(i) = 2i + 2

    创建堆的方式:
        > 插入式创建:
            每次插入一个节点,实现一个大顶堆(小顶堆)
        > 原地创建:
            堆化，给定一组节点，实现一个大顶堆(小顶堆)
*/

// 交换位置
var swap = function(items, i, j) {
    let temp = items[i];
    items[i] = items[j];
    items[j] = temp;
};

// 定义堆
var Heap = function() {
    let items = [,];

    // 插入式创建
    let insert = (key) => {
        items.push(key);

        // 获取存储位置
        let i = items.length - 1;

        // 遍历
        while(Math.floor(i/2) > 0 && items[i] > items[Math.floor(i/2)]) {
            swap(items, i, Math.floor(i/2));
            i = i / 2;
        }
    };
};




