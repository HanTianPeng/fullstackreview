### 栈
  - 后入先出,比如子弹弹夹,先装进去的在底部,后装进去的在顶部
  - 栈内元素只能通过列表的一端访问,这一端称为``栈顶(反之栈底)``
  - 插入新元素,称为``进栈/入栈/压栈``
  - 删除元素, 成为``出栈/退栈``

  - 01-栈与递归

  - 02-BFS应用
    - 二叉树层序遍历

    - 无权图最短路径

  - 03-优先队列
    - 手写堆

    - 手写优先队列

    - 应用
  
  - 04-双端队列

  - 05-栈与队列的互相实现
    - 栈实现队列

    - 队列实现栈

### 队列
  - 先进先出,比如排队,排在前面的先办完事情,后来的人只能从后面继续排队
  - 队尾插入元素, 队首删除元素

### 链表
  - 由一系列``节点``组成的集合,每个节点都使用一个对象的引用指向它的后继,指向另一个节点的引用叫``链``
  - 链表元素靠相互之间的关系进行引用A->B->C,B并不是链表的第二个元素而是B跟在A后面
  - 遍历链表就是跟着链接,从链接的首元素一直到尾元素,但不包含``头节点``,头元素常常被称为``链表的接入点``,(链表的尾元素指向一个null节点)
  - 向单向链表插入一个节点,需要修改它前面的节点(前驱)使其指向新加入的节点,而新加入的节点则指向原来前驱指向的节点
  - 从单向链表删除一个元素,需要将待删除的元素的前驱节点指向待删除元素的后继节点,同时将删除节点元素指向null

  - 01-反转链表系列

  - 02-环形链表系列

  - 03-合并链表系列

  - 04-求链表中间节点系列

### 字典
  -

### 散列
  - 散列后的数据可以快速插入取用
  - 在散列表上插入/删除/取用数据非常快,但是查找数据却效率低下,比如查找一组数据种的最大值和最小值
  - JavaScript散列是基于数组设计,理想情况散列函数会将每一个键值映射为唯一的数组索引,数组长度有限,更现实的实现策略是将键均匀分布
  - 数组长度是预先设定的,可以随时增加,所有元素根据和该元素对应的键,保存数组的特定位置
  - 即使使用高效的散列函数,仍然存在两个键值相同的情况,这种现象叫做``碰撞``
  - 数组的长度应该是一个质数,所有的策略都基于碰撞
  - 开链法: 两个键相同保存位置一样,开辟第二个数组,也称第二个数组为``链``
  - 线性探测法属于``开放寻址散列``,查找散列位置如果当前位置没有继续寻找下一个位置.存储数据较大较合适,数组大小>=1.5*数据(开链法),数组大小>=2*数据(线性探测法)

### 二叉树
  - 树是一种非线性的数据结构,分层存储
  - 树被用来存储具有层级关系的数据,还被用来存储有序列表
  - 二叉树进行查找特别快,二叉树的添加或删除也非常块
  - 集合中不允许相同成员存在

  - 01-遍历
    - 前序遍历

    - 中序遍历

    - 后序遍历
  
  - 02-最大/最小深度

  - 03-LCA问题

  - 04-对称二叉树

  - 05-路径相关问题
    - 二叉树直径

    - 所有路径

    - 最大路径和

  - 06-二叉搜索树
    - 验证二叉搜索树

    - 有序数组 -> 二叉搜索树

    - 不同的二叉搜索树

### 算法思维逻辑
  - 确定解题的数据结构: 单链表,双链表,循环链表....
  - 确定解题思路: 如何解决问题
  - 画图实现: 画图可以帮助我们发现思维中的漏洞
  - 确定边界条件: 思考解题中是否有边界问题以及如何解决
  - 代码实现: 解题完成
