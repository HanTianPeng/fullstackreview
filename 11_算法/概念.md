### 栈
  - 后入先出,比如子弹弹夹,先装进去的在底部,后装进去的在顶部
  - 栈内元素只能通过列表的一端访问,这一端称为``栈顶(反之栈底)``
  - 插入新元素,称为``进栈/入栈/压栈``
  - 删除元素, 成为``出栈/退栈``

### 队列
  - 先进先出,比如排队,排在前面的先办完事情,后来的人只能从后面继续排队
  - 队尾插入元素, 队首删除元素

### 链表
  - 由一系列``节点``组成的集合,每个节点都使用一个对象的引用指向它的后继,指向另一个节点的引用叫``链``
  - 链表元素靠相互之间的关系进行引用A->B->C,B并不是链表的第二个元素而是B跟在A后面
  - 遍历链表就是跟着链接,从链接的首元素一直到尾元素,但不包含``头节点``,头元素常常被称为``链表的接入点``,(链表的尾元素指向一个null节点)
  - 向单向链表插入一个节点,需要修改它前面的节点(前驱)使其指向新加入的节点,而新加入的节点则指向原来前驱指向的节点
  - 从单向链表删除一个元素,需要将待删除的元素的前驱节点指向待删除元素的后继节点,同时将删除节点元素指向null

### 字典
  -

### 散列
  - 散列后的数据可以快速插入取用
  - 在散列表上插入/删除/取用数据非常快,但是查找数据却效率低下,比如查找一组数据种的最大值和最小值
  - JavaScript散列是基于数组设计,理想情况散列函数会将每一个键值映射为唯一的数组索引,数组长度有限,更现实的实现策略是将键均匀分布
  - 数组长度是预先设定的,可以随时增加,所有元素根据和该元素对应的键,保存数组的特定位置
  - 即使使用高效的散列函数,仍然存在两个键值相同的情况,这种现象叫做``碰撞``
  - 数组的长度应该是一个质数,所有的策略都基于碰撞
  - 开链法: 两个键相同保存位置一样,开辟第二个数组,也称第二个数组为``链``
  - 线性探测法属于``开放寻址散列``,查找散列位置如果当前位置没有继续寻找下一个位置.存储数据较大较合适,数组大小>=1.5*数据(开链法),数组大小>=2*数据(线性探测法)

### 二叉树
  - 树是一种非线性的数据结构,分层存储
  - 树被用来存储具有层级关系的数据,还被用来存储有序列表
  - 二叉树进行查找特别快,二叉树的添加或删除也非常块
  - 集合中不允许相同成员存在
